#!/bin/sh
#
# fyr - 2019 (c) MIT | /bin/sh mpvc
# control mpv remotely using JSON ipc
# https://mpv.io/manual/master/#json-ipc

PROGNAME="$(basename "$0")"
PROGVERSION="1.3"

SOCKETCOMMAND=""
SOCKET="${MPVC_SOCKET:-$HOME/.config/mpvc/mpvsocket}"
MPVOPTIONS="--no-audio-display --no-input-terminal"

# print default status of mpv instance
[ -z "$FORMATSTRING" ] && FORMATSTRING="\
%artist% - %title%
[%status%] #%position%/%playlistlength% %time%/%length% (%percentage%%)
speed:%speed%x volume:%volume%% muted:%muted% repeat:%repeat% single:%single%"

usage() {
    cat >&2 << EOF
Usage: $PROGNAME [-S "socket"] [-a "filenames"] [-o "path"] [-f "format string"]
    -p | --toggle       : Toggle playback.
    -s | --stop         : Always stop playback.
    -P | --play         : Always start playback.
    -f | --format       : Enter a formatting string.
    -a | --add          : Add files to playlist.
    -i | --playlist     : Print filenames of tracks to fit within terminal.
    -I | --fullplaylist : Print all filenames of tracks in current playlist.
    -o | --save         : Save current playlist to given path.
    -j | --track        : Go forwards/backwards through the playlist queue.
    -J | --tracknum     : Jump to playlist item number.
    -z | --shuffle      : Shuffle the current playlist.
    -l | --loop         : Loop currently playing playlist.
    -L | --loopfile     : Loop currently playing file.
    -v | --vol          : Increase/decrease volume relative to current volume.
    -V | --volume       : Set absolute volume.
    -m | --mute         : Toggle sound.
    -t | --seek         : Increases/decreases time relatively, accepts % values.
    -T | --time         : Set absolute time.
    -x | --speed        : Increase/decrease speed relative to the current speed.
    -X | --speedval     : Set absolute speed.
    -I | --image        : Enable adding of images to the queue.
    -k | --kill         : Kill the mpv process controlling the given socket.
    -K | --killall      : Kill all mpv processes indiscriminately.
    -S | --socket       : Set socket location [default: $SOCKET].
    -q | --quiet        : Surpress all text output.
    -Q | --vid=no       : Start mpv with video output disabled.
    -- |                : After adding files options after -- are passed to mpv.
    -h | --help         : Print this help.

Formatting:
    \`$PROGNAME --format\` will interpret the following delimiters if they are found:

    %name%, %path%, %dir%, %title%, %artist%, %album%, %albumartist%, comment%,
    %genre%, %year%, %percentage%, %playlistlength%, %position%, %repeat%,
    %single, %status%, %time%, %precisetime%, %speed%, %length%, %remaining%,
    %volume%, %muted%, %frame%, %width%, %height%, %ab-loop-a%, %ab-loop-b%

MPC compatibility layer:
    mpvc features a nearly complete compatibility layer for mpc commands in
    addition to GNU style arguments. http://linux.die.net/man/1/mpc

Exit codes:
    0: Program ran succesfully.
    1: Input Argument error.
    2: Socket does not exist.
    3: Socket is not currently open.
    4: Dependency error.
EOF

    if [ -n "$1" ]; then exit "$1"; else exit; fi;
}

equiet() { "$@" 2> /dev/null; }
oquiet() { "$@" 1> /dev/null; }
quiet()  { "$@" > /dev/null 2>&1; }
warn() { echo "$@" >&2; }

_sockcmd() { echo "$@" | $SOCKETCOMMAND; }
sockcmd()  { oquiet _sockcmd "$@"; }

pprintf() { echo "$@"; }
eprintf() { warn "$@"; exit 1; }
eeprintf() { e=$1; shift; warn "$@"; exit "$e"; }

    # Retrieval Functions
###############################################################################

# match given filename string to appropriate output
# fn args: filename
cleanFilename() {
    filename="$1"
    result="$filename"
    case "$filename" in
        *.googlevideo.com/*) filename="mps-yt stream" ;;
        *youtu*|watch*)
            result="$(curl -sL "https://youtube.com/oembed?url=$filename" | getJSONField 'title:')"
        ;;
        *) result=$(basename "$filename") ;;
    esac
    printf '%s\n' "$result"
}

# fn args: media-title, path
getMediaProperties() {
    property="$1"
    socketCommand "get_property" "${property}" | escapeSedChar '&' '#'
}

# fn args: date, genre, title, album, artist, album_artist
getMetadata() {
    property=$1
    # test for no result
    metadata=$(getProperty "metadata/by-key/${property}")
    case "$metadata" in
        '') result="N/A" ;;
        *)  result="$metadata" ;;
    esac
    # test if title has no property and return filename instead
    if [ "$property" = "title" ]; then
        case "$metadata" in
            null) result=$(getPropertyString filename) ;;
            '') result=$(getPropertyString filename) ;;
            *) result=$(cleanFilename "$result") ;;
        esac
    fi
    printf '%s' "$result" | escapeSedChar '&' '#'
}

getJSONField() {
    awk -F, -v jfield="$1" '{
        gsub("[{\"}]","");
        for (i=1;i<=NF;i++) {
            if ($i ~ jfield) { gsub(jfield, "", $i); print $i }
        }
    }'
}

socketCommand() {
    command="$1"
    property="$2"
    # mimics jq JSON parsing using awk, but, should instead use jq(1) TBD
    equiet _sockcmd "{ \"command\": [ \"$command\", \"$property\"] }" | getJSONField "data:"
}

# retrieve integer/boolean property
# fn args: mute, pause, loop-file, estimated-frame-number, width, height
getProperty() {
    property="$1"
    result=$(socketCommand "get_property" "$property")
    echo "$result"
}

# fn args: filename, idle-active, playlist-count, playlist-pos, playback-time,
#          playtime-remaining, time-remaining, percent-pos, duration, volume
getPropertyString() {
    property="$1"
    result=$(socketCommand "get_property_string" "$property")
    case "$property" in
        volume|duration|percent-pos|playtime-remaining|playback-time)
            result="${result%%%}"
            result="${result%%.[0-9]*}"
        ;;
    esac
    echo "$result"
}

# fn args: speed
getSpeed() {
    getPropertyString "speed" | awk '{print substr ($0, 0, 4)}'
}

# fn args: loop-file, loop-playlist
getLoopStatus() {
    property=$1
    status=$(getProperty "$property")
    case "$status" in
        true | inf) loop="yes" ;;
        false)      loop="no"  ;;
        *)          loop="N/A" ;;
    esac
    printf '%s' "$loop"
}

getMuteStatus() {
    muted="$(getProperty mute)"
    case "$muted" in
        true)  muted="yes" ;;
        false) muted="no"  ;;
        *)     muted="N/A" ;;
    esac
    printf '%s' "$muted"
}

getPauseStatus() {
    status="$(getProperty pause)"
    case "$status" in
        true)  status="paused"  ;;
        false) status="playing" ;;
        *)     status="N/A"     ;;
    esac
    printf '%s' "$status"
}

# fn args: $1: filename $2: full path flag to skip basename
getPlaylistFilename() {
    track="$1"
    fullpathFlag="$2"
    filename=$(getPropertyString "playlist/$track/filename")
    [  "$fullpathFlag" != "fullpath" ] && filename=$(cleanFilename "$filename")
    printf '%s\n' "$filename"
}

# print filenames in current playlist
getPlaylist() {
    noColour="$1"
    fullPlaylist="$2"

    tracks=$(getPropertyString playlist-count)
    currentTrack=$(getPropertyString playlist-pos)

    if [ "$tracks" -eq 0 ]; then
        eprintf "$SOCKET is currently idle."
    fi

    # by default, display only tracks fitting terminal, otherwise, display all
    FIRST=1
    LAST=$tracks
    [ "$fullPlaylist" != "full" ] && calculateTerminalHeight "$currentTrack" "$tracks"

    for i in $( seq $(( FIRST - 1 )) $(( LAST - 1 )) )
    do
        filename=$(getPlaylistFilename "$i")
        if [ "$noColour" != "nocolour" ] && [ "$currentTrack" != "null" ] && [ "$currentTrack" -eq "$i" ]; then
            printf '%d	[7m %s[0m\n' "$i" "${filename}"
        else
            printf '%d	 %s\n' "$i" "${filename}"
        fi
    done
}

# open mpvc to retrieve all metadata from a playlist file
getFilenameMetadata() {
    intCheck "$1" || exit 1
    trackToMetadata="$1"
    getPlaylistFilename "$trackToMetadata" fullpath
}

# saves playlist to file but with no path checking. we live dangerously
savePlaylist() {
    saveLocation="$1"
    savePlaylist="$saveLocation.m3u"

    if [ -z "$saveLocation" ]
    then
        savePlaylist="/dev/stdout"
    else
        if [ -e "$savePlaylist" ]
        then
            echo "Playlist $savePlaylist exists! Overwrite? [Y/n] "; read -r key
            [ "$key" != "Y" ] && return
        fi
        printf '%s\n' "Adding files to $savePlaylist ..."
    fi

    LAST=$(getPropertyString playlist-count)
    for i in $(seq 0 $(( LAST - 1 )) )
    do
        printf '%s\n' "$(getPlaylistFilename "$i" fullpath)"
    done > "$savePlaylist"
    QUIETFLAG="true"
}

# loads a playlist from stdin
loadPlaylist() {
    QUIETFLAG="true"
    while read -r line;
    do
        if [ -e "$line" ]
        then
            appendTrack "${line}"
        fi
    done
}

    # Control Functions
###############################################################################

appendTrack() {
    filename="$*"
    # require absolute paths
    case "$filename" in
        /*) ;; *) [ -e "$filename" ] && filename="$(pwd)/$filename" ;;
    esac

    # skip over various other filetypes and images unless wanted
    # this doesn't stop mpv from resolving directories and adding them anyway
    case "$filename" in
        *.txt|*.log|*.cue) return ;;
        *.png|*.jpg|*.jpeg|*.gif|*.psd|*.pdf) [ "$IMAGEFLAG" != "true" ] && return ;;
        https*) ;;
    esac
    # start mpv socket up
    if ! quiet pgrep -f "mpv .*$SOCKET"; then
        startMpvd --really-quiet --idle=once
    fi
    quiet socketCommand "loadfile" "$filename\", \"append-play"
    filename=$(cleanFilename "$filename")
    printf '%s\n' "Adding: $filename"
}

appendTracks() {
    shiftcount=0
    QUIETFLAG="true"
    for arg in "$@";
    do
        if echo "$arg" | grep -q '^https\?://'; then
            appendTrack "$arg"
            shiftcount=$((shiftcount + 1))
        elif [ -e "$arg" ]; then
            appendTrack "$arg"
            shiftcount=$((shiftcount + 1))
        fi
    done
    return $shiftcount
}

playNext() {
    # add track to the playlist
    appendTrack "$1"
    # find position of track to move
    trackToMove="$(getPropertyString playlist-count)"
    # find position of current track
    newTrackPosition="$(getPropertyString playlist-pos)"
    QUIETFLAG="true"
    # set position of next track
    moveTrack "$trackToMove" "$((newTrackPosition + 1))"
}

setTimeRelative() {
    time=$(getPropertyString playback-time)
    case "$1" in
        *%*) sockcmd '{ "command": ["set_property", "percent-pos", '"${1%%%}"' ] }'; return ;;
        -*) timeArg=${1##-}; minusFlag=true ;;
        +*) timeArg=${1##+}; minusFlag=false ;;
        *)  timeArg=$1 ;;
    esac
    timeSec=$(parseTimeString "$timeArg") || exit $?
    case "$minusFlag" in
        true) time=$((time - timeSec)) ;;
        *)    time=$((time + timeSec)) ;;
    esac
    sockcmd '{ "command": ["set_property", "playback-time", '$time' ] }'
}

setTimeAbsolute() {
    timeSec=$(parseTimeString "$1") || exit $?
    trackTime=$(getPropertyString duration)
    if [ "$timeSec" -ge "$trackTime" ]; then
        printf '%s\n' "Given time is greater than track length! ($(getTrackLength))"
        QUIETFLAG="true"
        return 1
    fi
    sockcmd '{ "command": [ "set_property", "playback-time", '"$timeSec"' ] }'
}

setVolume () {
    intCheck "$1" || exit 1
    volume=$(getPropertyString volume)
    [ "$volume" = "error" ] && eprintf "Currently playing media does not have sound."
    case "$2" in
        relative) volume=$((volume + $1)) ;;
        absolute) volume=$1;;
    esac
    [ "$volume" -lt 0 ] && eprintf "Volume cannot be set lower than 0%"
    [ "$volume" -gt 130 ] && eprintf "Volume cannot be set great than 130%"
    sockcmd '{ "command": ["set_property", "volume", '"$volume"' ] }'
}

setSpeed() {
    fltCheck "$1" || exit 1
    speed=$(getSpeed)
    case "$2" in
        absolute) speed=$1 ;;
        relative) speed=$(echo "$speed $1" | awk '{print $1 + $2}') ;;
    esac
    sockcmd '{ "command": ["set_property_string", "speed", "'"$speed"'" ] }'
}

setTrack() {
    intCheck "$1" || exit 1
    currentTrack=$(getPropertyString playlist-pos)
    trackCount=$(getPropertyString playlist-count)
    case "$2" in
        relative)
            newTrack=$((currentTrack + $1))
            # if time is greater than 10 seconds, set time to 0
            if [ "$newTrack" -lt "$currentTrack" ]; then
                seconds=$(getPropertyString playback-time)
                [ "$seconds" -ge 10 ] && setTimeAbsolute 0 && return
            fi
            if [ "$newTrack" -ge "$trackCount" ]; then
                repeat=$(getLoopStatus loop-playlist)
                [ "$repeat" = "yes" ] && newTrack=0
            fi
            if [ "$newTrack" -lt 0 ]; then
                repeat=$(getLoopStatus loop-file)
                if [ "$repeat" = "yes" ]; then
                    newTrack=$trackCount
                else
                    newTrack=0
                fi
            fi
        ;;
        absolute) newTrack=$1 ;;
    esac
    if [ "$newTrack" -lt 0 ] || [ "$newTrack" -ge "$trackCount" ]; then
        eprintf "Item $newTrack is out of range of playlist."
    fi
    sockcmd '{ "command": ["set_property", "playlist-pos", '$newTrack' ] }'
}

moveTrack() {
    intCheck "$1" || exit 1
    if [ -z "$2" ]; then
        trackToMove=$(getPropertyString playlist-pos)
        newTrackPosition=$1
    else
        trackToMove=$1
        trackToMove=$((trackToMove - 1))
        newTrackPosition=$2
        trackCount=$(getPropertyString playlist-count)

        if [ "$trackToMove" -lt 0 ] || [ "$trackToMove" -ge "$trackCount" ]; then
            eprintf "Item $trackToMove is out of range of playlist."
        fi
    fi

    [ "$newTrackPosition" -lt 0 ] &&
        eprintf "Position $newTrackPosition is out of range of playlist."

    [ "$newTrackPosition" -eq 1 ] && newTrackPosition=0
    sockcmd '{ "command": ["playlist-move", "'$trackToMove'", "'$newTrackPosition'" ] }'

    if [ "$QUIETFLAG" != "true" ]; then
        getPlaylist "$COLOURFLAG"
        QUIETFLAG="true"
    fi
}

removeTrack() {
    trackToRemove=$1

    if [ "$trackToRemove" = "current" ]; then
        socketCommand "playlist-remove" "$trackToRemove"
    else
        intCheck "$1" || exit 1

        trackToRemove=$((trackToRemove - 1))
        trackCount=$(getPropertyString playlist-count)

        if [ "$trackToRemove" -lt 0 ] || [ "$trackToRemove" -ge "$trackCount" ]; then
            eprintf "Item $trackToRemove is out of range of playlist."
        fi

        filename="$(getPlaylistFilename $trackToRemove)"
        socketCommand "playlist-remove" "$trackToRemove"
    fi

    if [ "$QUIETFLAG" != "true" ]; then
        eprintf "$filename has been removed from the playlist."
    fi
}

alwaysPlay() {
    currentTrack=$(getPropertyString playlist-pos)
    if [ "$currentTrack" = "N/A" ]; then
        setTrack 1 absolute
        return
    fi
    sockcmd '{ "command": ["set_property", "pause", false ] }'
}

setPause() {
    pause=$1
    sockcmd '{ "command": ["set_property", "pause", '"$pause"' ] }'
}

togglePause() {
    currentTrack=$(getPropertyString playlist-pos)
    if [ "$currentTrack" = "N/A" ]; then
        setTrack 1 absolute; return
    fi
    pause="$(getProperty pause)"
    [  "$pause" = "true" ] && pause="false" || pause="true"
    sockcmd '{ "command": ["set_property", "pause", '"$pause"' ] }'
}

toggleMute() {
    if [  -z "$1" ]; then
        muted=$(getMuteStatus)
        [  "$muted" = "no" ] && muted="true" || muted="false"
    else
        muted=$1
    fi
    sockcmd '{ "command": ["set_property", "mute", '"$muted"' ] }'
}

toggleLoopFile() {
    loopFile=$(getLoopStatus loop-file)
    [ "$loopFile" = "no" ] && loopFile="inf" || loopFile="no"
    sockcmd '{ "command": ["set_property_string", "loop-file", "'$loopFile'" ] }'
}

toggleLoopPlaylist() {
    loopPlaylist=$(getLoopStatus loop-playlist)
    [ "$loopPlaylist" = "no" ] && loopPlaylist="inf" || loopPlaylist="no"
    sockcmd '{ "command": ["set_property_string", "loop-playlist", "'$loopPlaylist'" ] }'
}

shufflePlaylist() {
    sockcmd '{ "command": ["playlist-shuffle" ] }'

    [  "$QUIETFLAG" != "true" ] && {
        printf '%s\n' "Playlist shuffled."
        QUIETFLAG="true"
    }
    [ "$(getLoopStatus loop-playlist)" != "yes" ] && toggleLoopPlaylist inf
}

cropPlaylist() {
    sockcmd '{ "command": ["playlist-clear" ] }'

    [ "$QUIETFLAG" != "true" ] && {
        getPlaylist
        QUIETFLAG="true"
    }
}

clearPlaylist() {
    QUIETFLAG="true"
    # kill any running process of mpvc add
    quiet pgrep -f "mpvc add" && pkill -f "mpvc add"

    cropPlaylist
    removeTrack 1
    printf '%s\n' "Playlist cleared."
}

# quit mpv process on given socket
killSocket() {
    sockcmd '{ "command": ["quit"] }'
    exit
}

# kill all instances of mpv running under your user
killAllMpv() {
    quiet pkill "mpv"
    exit
}

    # Time Functions
###############################################################################

getElapsedTime() {
    time=$(getPropertyString playback-time)
    formatTime "$time"
}

getElapsedTimePrecise() {
    time=$(getPropertyString playback-time 0.0)
    bigTime=${time%%.*}
    tinyTime=${time#*.}
    formatTime "$bigTime" "$tinyTime"
}

getTrackLength() {
    duration=$(getPropertyString duration)
    formatTime "$duration"
}

playtimeRemaining() {
    playtime=$(getPropertyString playtime-remaining)
    formatTime "$playtime"
}

# format seconds into HH:MM:SS format
formatTime() {
    [  "$1" = "N/A" ] && return 1

    rawSeconds=$1
    seconds=$((rawSeconds % 60))
    minutes=$((rawSeconds / 60))
    hours=$((minutes / 60))

    [ $seconds -lt 10 ] && seconds="0$seconds"
    [ $minutes -ge 60 ] && minutes=$((minutes - hours*60))
    [ $minutes -lt 10 ] && minutes="0$minutes"
    [ $hours -lt 10 ] && hours="0$hours"

    if [ -z "$2" ]; then
        printf '%s\n' "$hours:$minutes:$seconds"
    else
        milleSeconds=$2
        printf '%s\n' "$hours:$minutes:$seconds.$milleSeconds"
    fi
}

    # Formatting and Printing Functions
###############################################################################

# formats and prints according to $FORMATSTRING
formatPrint() {
    # modified format string
    F="$FORMATSTRING"

    # not that nice, in fact, way more ugly, but too way faster
    for f in $(echo "$F" | sed 's#/# #g')
    do
        case $f in
        (*%status%*) F=$(echo "$F" | sed "s#%status%#$(getPauseStatus)#g") ;;
        (*%year%*) F=$(echo "$F" | sed "s#%year%#$(getMetadata date)#g") ;;
        (*%genre%*) F=$(echo "$F" | sed "s#%genre%#$(getMetadata genre)#g") ;;
        (*%title%*) F=$(echo "$F" | sed "s#%title%#$(getMetadata title)#g") ;;
        (*%album%*) F=$(echo "$F" | sed "s#%album%#$(getMetadata album)#g") ;;
        (*%artist%*) F=$(echo "$F" | sed "s#%artist%#$(getMetadata artist)#g") ;;
        (*%comment%*) F=$(echo "$F" | sed "s#%comment%#$(getMetadata comment)#g") ;;
        (*%albumartist%*) F=$(echo "$F" | sed "s#%albumartist%#$(getMetadata album_artist)#g") ;;
        (*%speed%*) F=$(echo "$F" | sed "s#%speed%#$(getSpeed)#g") ;;
        (*%time%*) F=$(echo "$F" | sed "s#%time%#$(getElapsedTime)#g") ;;
        (*%precisetime%*) F=$(echo "$F" | sed "s#%precisetime%#$(getElapsedTimePrecise)#g") ;;
        (*%playback-time%*) F=$(echo "$F" | sed "s#%playback-time%#$(getProperty playback-time)#g") ;;
        (*%volume%*) F=$(echo "$F" | sed "s#%volume%#$(getPropertyString volume)#g") ;;
        (*%length%*) F=$(echo "$F" | sed "s#%length%#$(getTrackLength)#g") ;;
        (*%remaining%*) F=$(echo "$F" | sed "s#%remaining%#$(playtimeRemaining)#g") ;;
        (*%muted%*) F=$(echo "$F" | sed "s#%muted%#$(getMuteStatus)#g") ;;
        (*%percentage%*) F=$(echo "$F" | sed "s#%percentage%#$(getPropertyString percent-pos)#g") ;;
        (*%name%*) F=$(echo "$F" | sed "s#%name%#$(getMediaProperties filename)#g") ;;
        (*%path%*) F=$(echo "$F" | sed "s#%path%#$(getMediaProperties path)#g") ;;
        (*%dir%*) F=$(echo "$F" | sed "s#%dir%#$(getPropertyString working-directory)#g") ;;
        (*%repeat%*) F=$(echo "$F" | sed "s#%repeat%#$(getLoopStatus loop-playlist)#g") ;;
        (*%single%*) F=$(echo "$F" | sed "s#%single%#$(getLoopStatus loop-file)#g") ;;
        (*%playlistlength%*) F=$(echo "$F" | sed "s#%playlistlength%#$(getPropertyString playlist-count)#g") ;;
        (*%position%*) F=$(echo "$F" | sed "s#%position%#$(($(getPropertyString playlist-pos) + 1))#g") ;;
        (*%frame%*) F=$(echo "$F" | sed "s#%frame%#$(getProperty estimated-frame-number)#g") ;;
        (*%width%*) F=$(echo "$F" | sed "s#%width%#$(getProperty width)#g") ;;
        (*%height%*) F=$(echo "$F" | sed "s#%height%#$(getProperty height)#g") ;;
        (*%ab-loop-a%*) F=$(echo "$F" | sed "s#%ab-loop-a%#$(getPropertyString ab-loop-a)#g") ;;
        (*%ab-loop-b%*) F=$(echo "$F" | sed "s#%ab-loop-b%#$(getPropertyString ab-loop-b)#g") ;;
        esac
    done
    echo "${F}"
}

printPrettyOutput() {
    exit 0
}

# catches if mpv is idle or not
printFinalOutput() {
    if [ "$QUIETFLAG" != "true" ] && [ "$(getPropertyString idle-active)" = "yes" ]; then
        printf '%s\n' "MPV instance on $SOCKET is currently idle." >&2
    else
        formatPrint
        exit
    fi
}

    # Misc. Functions
###############################################################################

escapeSedChar() {
    awk -v r1="$1" -v r2="$2" '{ gsub(r1, "\\"r1); gsub(r2, "\\"r2); print $0; }'
}

intCheck() {
    [ "$1" -ne 0 ] 2> /dev/null
    [ "$?" -ne 2 ] || return 1
}

fltCheck() {
    intCheck "$1" && return 0
    case "$1" in
        *[0-9].[0-9]*)    return 0 ;;
        *.*.*|*[!-.0-9]*) ;;
    esac
    return 1
}

getCurrentLine() {
    l=2
#    t=$(stty -g)
#
#    exec < /dev/tty
#    stty raw -echo min 0
#    tput u7 > /dev/tty
#    sleep 0.1
#    IFS='[;' read -r R l
#    stty "$t"
    echo "${l%%;*}"
}

calculateTerminalHeight() {
    ctrack="$1"
    tracks="$2"
    lines=$(tput lines)
    crow=$(getCurrentLine)
    rows=$((lines - crow))
    halfrows=$((rows / 2))

    if [ -z "$ctrack" ] ||  [ "$ctrack" = "null" ]; then
        return
    fi

    if [ "$tracks" -le $rows ]; then
        FIRST=1; LAST=$tracks
    elif [ "$ctrack" -le $halfrows ]; then
        FIRST=1; LAST=$rows
    elif [  $((ctrack + halfrows)) -ge "$tracks" ]; then
        FIRST=$((tracks - rows + 1)); LAST=$tracks
    elif [  $((ctrack + halfrows)) -lt "$tracks" ]; then
        FIRST=$((ctrack - halfrows + 1)); LAST=$((ctrack + halfrows))
    fi
}

parseTimeString() {
    printf '%s' "$1" | grep -q -e "^\([0-9.]*:\)\{0,2\}[0-9.]*$" -e "^[0-9]*[sSmMhH]$" || {
        cat >&2 << EOF
Timestamp formats must match either H:M:S with hour and minute fields optional,
or a single integer number with a unit of time appended: h, m, s.
EOF
        exit 1
    }

    case "$1" in
        *s|*S|*m|*M|*h|*H)
            timeInt=${1%%?}
            intCheck "$timeInt" || exit 1
            case "$1" in
                *h|*H) timeInt=$((timeInt * 60 * 60)) ;;
                *m|*M) timeInt=$((timeInt * 60))      ;;
            esac
            ;;
        *)
            timeInt=$(printf '%s' "$1" | awk -F ':' '{
                for (x=1; x<=NF; x++) time=time*60+$x;
                print time
            }')
            ;;
    esac
    printf "%d" "$timeInt"
}

validateDeps() {
    if ! quiet type mpv; then
        eeprintf 4 "Cannot find mpv on your \$PATH."
    fi
    quiet type nc && SOCKETCOMMAND="nc -U -N $SOCKET"
    quiet type socat && SOCKETCOMMAND="socat - $SOCKET"
    if [ -z "$SOCKETCOMMAND" ]; then
        eeprintf 4 "Cannot find socat or nc on your \$PATH."
    fi
}

validateSocket() {
    # test if socket exists
    if [ ! -S "$SOCKET" ]; then
        eeprintf 2 "$SOCKET does not exist. Use mpv --input-ipc-server to start one."
    fi
    # test if socket is open
    if [ "$(getPauseStatus)" = "N/A" ]; then
        eeprintf 3 "No files added to $SOCKET."
    fi
}

getVersion() {
    mpv --version
    echo "MPVC Release $PROGVERSION (c) Laurence Willetts MIT"
    exit
}

do_fuzzy_search() {
    true
}

do_idleloop() {
    sockcmd '{ "command": ["unobserve_property", 1 ] }'
    sockcmd '{ "command": ["observe_property", '1, "$*"' ] }'
    socat -t0 -,ignoreeof "$SOCKET"
}

startMpvd() {
    mkdir -p "$(dirname "$SOCKET")"
    # shellcheck disable=SC2086
    exec mpv --input-ipc-server="$SOCKET" $MPVOPTIONS "$@" &
    # wait until mpv starts up
    until [ -n "$(getPropertyString idle-active)" ]; do sleep 0.1; done
}

main() {
    validateDeps
    # more global argument parsing
    for arg in "$@"; do
        [ "$SOCKETFLAG" = "true" ] && SOCKET=$arg && SOCKETFLAG=false
        [ "$FORMATFLAG" = "true" ] && FORMATSTRING=$arg && FORMATFLAG=false

        # grab mpv options first if any
        [ "$arg" = "--" ] && MPVFLAG=true
        if [ "$MPVFLAG" = "true" ]; then
            MPVOPTIONS="$MPVOPTIONS $arg"
        else
            case $arg in
                -Q|--vid=no)      MPVOPTIONS="$MPVOPTIONS --vid=no"; shift ;;
                -S|--socket)      SOCKETFLAG=true; shift                   ;;
                -f|--format)      FORMATFLAG=true; shift                   ;;
                --image)          IMAGEFLAG=true; shift                    ;;
                -q|--quiet)       QUIETFLAG=true; shift                    ;;
                --mono|mono)      COLOURFLAG=nocolour; shift               ;;
                --colour|colour)  COLOURFLAG=colour; shift                 ;;
            esac
        fi
    done

    # grab piped input for input if it exists
    [ -p /dev/stdin ] && loadPlaylist

    # mpc compatibility layer
    case "$1" in
        play|start|resume)
            case "$2" in
                0) setTrack 1 absolute;;
                $) setTrack "$(getPropertyString playlist-count)" absolue;;
                *) intCheck "$2" && setTrack "$2" absolute;;
            esac
            alwaysPlay
            printFinalOutput
        ;;
        vol|volume)
            case "$2" in
                '') eprintf "Specify volume in/decrease amount or absolute amount." ;;
                +*) setVolume "$2" relative ;;
                -*) setVolume "$2" relative ;;
                *)  setVolume "$2" absolute ;;
            esac
            printFinalOutput
        ;;
        repeat)
            case "$2" in
                on)  toggleLoopPlaylist inf ;;
                off) toggleLoopPlaylist no  ;;
                *)   toggleLoopPlaylist     ;;
            esac
            printFinalOutput
        ;;
        single)
            case "$2" in
                on)  toggleLoopFile yes ;;
                off) toggleLoopFile no  ;;
                *)   toggleLoopFile     ;;
            esac
            printFinalOutput
        ;;
        sockcmd)  _sockcmd "$2"; return ;;
        metadata) getFilenameMetadata "$2" ;;
        pause)    setPause true       ; printFinalOutput ;;
        next)     setTrack 1 relative ; printFinalOutput ;;
        prev)     setTrack -1 relative; printFinalOutput ;;
        move)     moveTrack "$2" "$3" ; printFinalOutput ;;
        mute)     toggleMute true     ; printFinalOutput ;;
        unmute)   toggleMute false    ; printFinalOutput ;;
        pretty)   printPrettyOutput ;;
        find)     do_fuzzy_search "$@"; return ;;
        idleloop) do_idleloop "$@"; return ;;

        add|-a|--append) appendTracks "$@"; shift "$((shiftcount + 1))" ;;
        playnext|-A|--playnext) ;;
        mpv|--mpv)     startMpvd --idle=yes --input-terminal; return;;
        *) validateSocket ;;
        # consume) to implement # add on|off toggle
        # random) MPV doesn't have this control option!
        # create an issue or implement pseudo-random tracks
    esac

    # GNU-style options
    for arg in "$@"; do
        case "$1" in
            -t|--seek|seek)                  shift; setTimeRelative "$1"    ;;
            -T|--time)                       shift; setTimeAbsolute "$1"    ;;
            -v|--vol)                        shift; setVolume "$1" relative ;;
            -V|--volume)                     shift; setVolume "$1" absolute ;;
            -x|--speed|speed)                shift; setSpeed "$1" relative  ;;
            -X|--speedval)                   shift; setSpeed "$1" absolute  ;;
            -j|--track)                      shift; setTrack "$1" relative  ;;
            -J|--tracknum)                   shift; setTrack "$1" absolute  ;;
            -r|--remove|rm|remove|del)       shift; removeTrack "$1"        ;;
            -o|--save|save)                  shift; savePlaylist "$1"       ;;
            --load|load)                     shift; loadPlaylist "$1"       ;;
            -A|--playnext|playnext)          shift; playNext "$1"           ;;

            -k|--kill|kill)                  killSocket                     ;;
            -K|--killall)                    killAllMpv                     ;;

            -s|--stop|stop)                  setPause true; setTimeAbsolute 0 ;;
            -P|--play|play)                  alwaysPlay                     ;;
            -p|--toggle|toggle)              togglePause                    ;;
            -m|--mute)                       toggleMute                     ;;
            mute)                            toggleMute true                ;;
            unmute)                          toggleMute false               ;;
            -i|--playlist|playlist)          getPlaylist "$COLOURFLAG" ""; exit;;
            -I|--fullplaylist|fullplaylist)  getPlaylist "$COLOURFLAG" "full"; exit;;
            -L|--loop|loop)                  toggleLoopPlaylist             ;;
            -l|--loopfile|loopfile)          toggleLoopFile                 ;;
            -z|--shuffle|shuffle)            shufflePlaylist                ;;
            -c|--crop|crop)                  cropPlaylist                   ;;
            -C|--clear|clear)                clearPlaylist                  ;;
            -f|--format)                     continue                       ;;
            -a|--append)                     continue                       ;;
            -S|--socket)                     continue                       ;;
            -[1-9][0-9][0-9][0-9][0-9][0-9]) continue                       ;;
            --|---|----)                     continue                       ;;

            --version|version)               getVersion                     ;;
            --list-options)                  usage 0                        ;;
            -h|--help|h|help)                usage 0                        ;;
            -?)                              usage 1                        ;;
        esac
        [ -n "$1" ] && shift
    done
    # produce format strings last
    [ "$QUIETFLAG" != "true" ] && printFinalOutput
}

if [ "$QUIETFLAG" = "true" ]; then
    quiet main "$@"
else
    main "$@"
fi
